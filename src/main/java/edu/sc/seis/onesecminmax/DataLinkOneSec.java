/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.sc.seis.onesecminmax;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoField;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import com.martiansoftware.jsap.FlaggedOption;
import com.martiansoftware.jsap.JSAP;
import com.martiansoftware.jsap.JSAPException;
import com.martiansoftware.jsap.JSAPResult;
import com.martiansoftware.jsap.Parameter;
import com.martiansoftware.jsap.QualifiedSwitch;
import com.martiansoftware.jsap.SimpleJSAP;
import com.martiansoftware.jsap.stringparsers.FileStringParser;

import edu.iris.dmc.seedcodec.CodecException;
import edu.iris.dmc.seedcodec.SteimException;
import edu.iris.dmc.seedcodec.UnsupportedCompressionType;
import edu.sc.seis.seisFile.datalink.DataLink;
import edu.sc.seis.seisFile.datalink.DataLinkException;
import edu.sc.seis.seisFile.datalink.DataLinkPacket;
import edu.sc.seis.seisFile.datalink.DataLinkResponse;
import edu.sc.seis.seisFile.mseed.DataRecord;
import edu.sc.seis.seisFile.mseed.SeedFormatException;
import edu.sc.seis.seisFile.mseed.SeedRecord;

public class DataLinkOneSec {

    private boolean VERBOSE = false;

    public DataLinkOneSec(File minMaxDir) {
        VERBOSE  = false;
        this.minMaxDir = minMaxDir;
        yearFormatter = DateTimeFormatter.ofPattern("yyyy").withZone(ZoneId.of("UTC"));
        doyFormatter = DateTimeFormatter.ofPattern("DDD").withZone(ZoneId.of("UTC"));
        formatter = DateTimeFormatter.ofPattern("yyyy.DDD.HH").withZone(ZoneId.of("UTC"));
        if (!minMaxDir.exists()) {
            throw new RuntimeException("min max dir doesn't exist: " + minMaxDir);
        }
    }
    
    private static final ZoneId UTC_ZONE = ZoneId.of("Z");

    public void init() throws DataLinkException {
        inDataLink = new DataLink(DataLink.EEYORE_HOST, DataLink.EEYORE_PORT, 30, VERBOSE);
        inDataLink.match("CO_BIRD_00_HH.");
    }

    public void run() {
        try {
            int count = 0;
            inDataLink.stream();
            while (keepGoing && count < 100) {
                count++;
                DataLinkResponse response = inDataLink.readPacket();
                if (response instanceof DataLinkPacket) {
                    processDataPacket((DataLinkPacket) response);
                }
            }
            inDataLink.endStream();
            sendRemining();

        } catch (DataLinkException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (SeedFormatException e) {
            e.printStackTrace();
        } catch (SteimException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            inDataLink.close();
        }
    }

    public void processMiniseedFile(DataInputStream dis)
            throws SeedFormatException, IOException, UnsupportedCompressionType, CodecException {
        try {
        while (true) {
            SeedRecord sr = SeedRecord.read(dis, 0);
            if (sr instanceof DataRecord) {
                processDataRecord((DataRecord) sr);
            }
        }
        } catch(EOFException e) {
            sendRemining();
            throw e;
        }
    }

    void processDataPacket(DataLinkPacket packet)
            throws DataLinkException {
        if (packet.getStreamId().endsWith("/MSEED")) {
            DataRecord dr = packet.getMiniseed();
            try {
                processDataRecord(dr);
            } catch (SeedFormatException e) {
                throw new DataLinkException(e);
            } catch (CodecException e) {
                throw new DataLinkException(e);
            }
        }
    }

    void processDataRecord(DataRecord dr) throws SeedFormatException, CodecException {  

        OneSecMinMax onesec = new OneSecMinMax(dr);
        OneSecMinMax prev = lastOneSecMap.get(onesec.key);
        if (prev != null) {
            if (prev.isContiguous(onesec)) {
                prev.concat(onesec);
                onesec = prev;
                prev = null;
            } else {
                System.out.println("Not Contig " + prev.start + " " + prev.maximum.length + "  " + onesec.start);
                sendMinMax(prev);
                prev = null;
            }
        }
        if (sendThreashold > 0 && onesec.maximum.length >= sendThreashold) {
            sendMinMax(onesec);
            lastOneSecMap.remove(onesec.key);
        } else {
            lastOneSecMap.put(onesec.key, onesec);
        }
    }
    
    private void sendRemining() throws SeedFormatException, SteimException {
        for (OneSecMinMax onesec : lastOneSecMap.values()) {
            sendMinMax(onesec);
        }
    }

    private void sendMinMax(OneSecMinMax onesec) throws SeedFormatException, SteimException {
        try {
            //System.out.println("Pretend Send MinMax: " + onesec.key + " " + onesec.minimum.length);
            ArrayList<DataRecord> minMaxList = MiniSeedFactory.createMiniseed(onesec);
            DataRecord dr = minMaxList.get(0);
            String netCode =  dr.getHeader().getNetworkCode().trim();
            String staCode =  dr.getHeader().getStationIdentifier().trim();
            String locCode =  dr.getHeader().getLocationIdentifier().trim();
            String chanCode =  dr.getHeader().getChannelIdentifier().trim();

            ZonedDateTime start = ZonedDateTime.ofInstant(onesec.start, UTC_ZONE);
            String[] split = onesec.keyAsNSLC();
            File netDir = new File(minMaxDir, netCode);
            File staDir = new File(netDir, staCode);
            String year = yearFormatter.format(start);
            File yearDir = new File(staDir, year);
            String doy = doyFormatter.format(start);
            File jdayDir = new File(yearDir, doy);
            jdayDir.mkdirs();
            File minmax = new File(jdayDir, netCode+"." +staCode+"." +locCode+"." +chanCode + "." + formatter.format(onesec.start));

            DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(minmax, true)));
            for (DataRecord dataRecord : minMaxList) {
                dataRecord.write(dos);
            }
            dos.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void OLDsendMinMax(OneSecMinMax onesec) {
        ZonedDateTime start = ZonedDateTime.ofInstant(onesec.start, UTC_ZONE);
        String[] split = onesec.key.split("\\.");
        File netDir = new File(minMaxDir, split[0]);
        File staDir = new File(netDir, split[1]);
        String year = yearFormatter.format(start);
        File yearDir = new File(staDir, year);
        String doy = doyFormatter.format(start);
        File jdayDir = new File(yearDir, doy);
        jdayDir.mkdirs();
        File minmax = new File(jdayDir, onesec.key + "." + formatter.format(onesec.start));
        try {
            DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(minmax, true)));
            dos.writeShort(start.get(ChronoField.YEAR));
            dos.writeShort(start.get(ChronoField.DAY_OF_YEAR));
            dos.writeByte(start.get(ChronoField.HOUR_OF_DAY));
            dos.writeByte(start.get(ChronoField.MINUTE_OF_HOUR));
            dos.writeByte(start.get(ChronoField.SECOND_OF_MINUTE));
            dos.writeByte(onesec.key.length());
            dos.writeBytes(onesec.key);
            dos.writeShort(onesec.maximum.length);
            for (int i = 0; i < onesec.minimum.length; i++) {
                dos.writeInt(onesec.minimum[i]);
                dos.writeInt(onesec.maximum[i]);
            }
            dos.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    int sendThreashold = 1000;

    File minMaxDir;

    private DateTimeFormatter yearFormatter;
    private DateTimeFormatter doyFormatter;
    private DateTimeFormatter formatter;

    HashMap<String, OneSecMinMax> lastOneSecMap = new HashMap<String, OneSecMinMax>();

    DataLink inDataLink;

    boolean keepGoing = true;

    static JSAPResult parseCmdLine(String[] args) {
        SimpleJSAP jsap;
        try {
            jsap = new SimpleJSAP("OneSecMinMax", 
                                  "One sec min max from miniseed",
                                  new Parameter[] {
                                          new FlaggedOption( "file", FileStringParser.getParser().setMustExist(true), JSAP.NO_DEFAULT, JSAP.REQUIRED, 'f', JSAP.NO_LONGFLAG, 
                                                  "A miniseed file." ),
                                          new FlaggedOption( "outputdir", FileStringParser.getParser().setMustBeDirectory(true), JSAP.NO_DEFAULT, JSAP.REQUIRED, 'o', JSAP.NO_LONGFLAG, 
                                                  "A miniseed file." ),
                                          new QualifiedSwitch( "verbose", JSAP.STRING_PARSER, JSAP.NO_DEFAULT, JSAP.NOT_REQUIRED, 'v', "verbose", 
                                                  "Requests verbose output." ).setList( true ).setListSeparator( ',' )
                                  }
                    );
                                     
        JSAPResult config = jsap.parse(args); 
        if ( ! config.success()) {
            Iterator it = config.getErrorMessageIterator();
            while (it.hasNext()) {
                System.err.println(it.next());
            }
        }
        return config;
        } catch (JSAPException e) {
           throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        try {
            JSAPResult config = parseCmdLine(args);
            if ( ! config.success()) {
                System.err.println("Can't parse cmd line args, quiting");
                return;
            }
            DataLinkOneSec app = new DataLinkOneSec(config.getFile("outputdir"));

            //app.minMaxDir = new File("/data/minmax");
            
            
            if (config.contains("file")) {
                File miniseedFile = config.getFile("file");
                if (miniseedFile.canRead()) {
                    DataInputStream dis = null;
                    try {
                        dis = new DataInputStream(new BufferedInputStream(new FileInputStream(miniseedFile)));
                        app.processMiniseedFile(dis);

                    } catch (EOFException e) {
                        System.out.println("EOF, All Done!");
                    } finally {
                        if (dis != null) dis.close();
                    }
                }
            } else {
                app.init();
                app.run();
            }
            System.out.println("All Done!");
        } catch (DataLinkException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (SeedFormatException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (UnsupportedCompressionType e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (CodecException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
